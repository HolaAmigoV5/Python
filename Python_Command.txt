#!/usr/bin/env python3
# -*- coding: utf-8 -*-

--Python基础
print("hello world")
classmates=['Michael','Bob','Tracy']
len(classmates)
classmates[0]
classmates[-1]  #获取倒数第一个元素
classmates[-2]  #获取倒数第二个元素
classmates.append('Adam')
classmates.insert(1,'Jack')
classmates.pop()  #删除末尾元素
classmates.pop(1) #删除指定位置的元素
L=['Apple',123,True]  #list里面的元素的数据类型可以不同
s=['python','java',['asp','php'],'scheme']  #list里面可以是另一个list

t=(1,2)  #定义一个tuple，其元素必须确定下来
t=(1)   t=(1,)   #区别:第一个是数学公式，第二个才是1个元素的tuple
t=('a','b',['A','B'])

age=3
if age>=18:
   print('your age is',age)
   print('adult')
else:
   print('your age is',age)
   print('teenager')

names=['Michael','Bob','Tracy']
for name in names:
    print(name)
	
for i in range(1, 10) :
    for j in range(1, i+1) :
        print(j, 'x', i, '=', j*i, '\t',)
    print('\n')
	
d={'Michael':95,'Bob':75,'Tracy':85}
d['Jack']=98
'Thomas' in d #判断Thomas是否在d中
d.get('Thomas') #如果不存在，返还None
d.get('Thomas',-1) #如果不存在，返还指定的-1
d.pop('Bob')
s=set([1,2,3])

--函数
def my_abs(x):
   if not isinstance(x,(int,float)):    #参数检查
      raise TypeError('bad operand type')
   if x>=0:
     return x
   else:
     return -x
	 
from abstest import my_abs  #从文件abstest中导入my_abs函数，注意abstest没有.py后缀

def pop():
    pass
	
import math
def move(x,y,step,angle=0):
    nx=x+step*math.cos(angle)
	ny=y-step*math.sin(angle)
	return nx,ny
    
#位置参数
def enroll(name,gender,age=6,city='Beijing'):
    print('name:',name)
    print('gender:',gender)
    print('age:',age)
    print('city:',city)
    
#可变参数，函数内部参数numbers接收到的是一个tuple
def calc(*numbers):
    sum=0
    for n in numbers:
        sum=sum+n*n
    return sum
    
#关键字参数，函数内部参数kw接收到的是一个dict
def person(name,age,**kw):
    print('name:',name,'age:',age,'Other:',kw)
    
>>>extra={'city':'Beijing','Job':'Engineer'}
>>>person('Jack',24,city=extra['city'],Job=extra['Job'])
>>>person('Jack',24,**extra)
name:Jack age:24 other:{'city':'Beijing','Job':'Engineer'}
def person(name,age,**kw):
    if 'city' in kw:
        #有city参数
    if 'Job' in kw:
        #有Job参数
    print('name:',name,'age:',age,'Other:',kw)

#命名关键字参数,*后面的参数被视为命名关键字参数
#命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错
def person(name,age,*,city,job):
    print(name,age,city,job)
#命名关键字参数可以有缺失值，调用时，可不传入city参数
def person(name,age,*,city='Beijing',job)
    print(name,age,city,job)
    
#五种参数：必选参数，默认参数，可变参数，关键字参数，命名关键字参数
#除了可变参数无法和命名关键字参数混合使用，其他可以组合使用
#参数定义的顺序必须是：必选参数，默认参数，可变参数/命名关键字参数和关键字参数，如下：
def fl(a,b,c=0,*args,**kw):
    print('a=',a,'b=',b,'c=',c,'args=',args,'kw=',kw)
def f2(a,b,c=0,*,d,**kw):
    print('a=',a,'b=',b,'c=',c,'args=',args,'kw=',kw)

#小结
#*args是可变参数，args接收的是一个tuple;
#**kw是关键字参数，kw接收的是一个dict

#递归函数
def fact(n):
        if n==1:
            return 1
        else:
            return n*fact(n-1)
            
 #尾递归

def fact(n):
    return fact_iter(n,1)

def fact_iter(num,product):
    if num==1:
        return product
    return fact_iter(num-1,num*product)
	
--高级特性
>>>L=['Michael','Sarah','Tracy','Bob','Jack']
>>>L[0:3]   #切片：从索引0开始取，直到索引3为止，但不包括索引3
>>>L[:3]    #同上，简写方式
>>>L[-2:]             ['Bob','Jack']
>>>L[-2:-1]           ['Bob']

>>>L=list(range(100))
>>>L[:10:2]    #前10个数，每两个取一个
[0,2,4,6,8]
>>>L[::5]      #所有数，每5个取一个
[0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95]

#默认情况下，dict迭代的是key。如果迭代value，可以用for value in d.values()，如果同时迭代key和value，可以使用for k,v in d.items()

#Python内置的enumerate函数可以把一个list变成索引-元素对，如下：
>>>for i ,value in enumerate(['A','B','C']):
...     print(i,value)
...
0 A
1 B
2 C

>>>for x,y in [(1,1),(2,4),(3,9)]:
...     print(x,y)
...
1 1
2 4
3 9

#列表生成式
>>>[X * X for X in range(1,11)]
[1,4,9,16,25,36,49,64,81,100]

>>>[X * X for X in range(1,11) if X % 2==0]
[4,16,36,64,100]

>>>[m + n for m in 'ABC' for n in 'XYZ']
['AX','AY','AZ','BX','BY','BZ','CX','CY','CZ']

#生成器(generator)
#方法一，将一个列表生成式的[]改成()，就创建了一个generator
>>>L=[x*x for x in range(10)]
>>>L
[0,1,4,9,16,25,36,49,64,81]
>>>g=(x*x for x in range(10))
>>>g
<generator object<genexpr> at 0x1022ef630>

#方法二，函数定义中包含yield关键字就不是普通的函数，而是一个generator
#斐波拉契数列generator
def fib(max):
    n,a,b=0,0,1
    while n<max:
        yield b
        a,b=b,a+b
        n=n+1
    return 'done'
    
#注意区分普通函数和generator函数，普通函数调用直接返回结果
>>>r=abs(6)
>>>r
6
#generator函数的“调用”实际返回一个generator对象
>>>g=fib(6)
>>>g
<generator object fib at 0x1022ef948>

#可直接作用于for循环的数据类型有以下几种
#一类是集合数据类型，如list、tuple、dict、set、str等：
#一类是generator，包括生成器和带yield的generator function
#这些可以直接作用于for循环的对象统称为可迭代对象:Iterable
#可以用isinstance()判断一个对象是否是Iterable对象

#可以被next()函数调用并不断返还下一个值的对象称为迭代器：Iterator
#可以用isinstance()判断一个对象是否是Iterator对象

#生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator
#把list、dict、str等Iterable变成Iterator可以使用iter()函数

--函数式编程
#变量可以指向函数
>>>f=abs
>>>f(-10)
10
#函数名也是变量
>>>abs=10
>>>abs(-10)
Traceback(most recent call last):
    File "<stdin>",line 1,in <module>
TypeError:'int' object is not callable
#传入函数
def add(x,y,f):
    return f(x)+f(y)
>>>add(-5,6,abs)  #第三个传入的是abs()函数，abs(-5)+abs(6)=11
11  

#高阶函数 map()
#map()传入的第一个参数是f,即函数对象本身，由于结果r是一个Iterator,
#Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list
>>>def f(x):
...     return x*x
...
>>>r=map(f,[1,2,3,4,5,6,7,8,9])
>>>list(r)
[1,4,9,16,25,36,49,64,81]

>>>list(map(str,[1,2,3,4]))
['1','2','3','4']

#reduce()把一个函数作用在序列[x1,x2,x3,...]上，这个函数必须接收两个参数
#reduce把结果继续和序列的下一个元素做累积计算，其效果如下：
reduce(f,[x1,x1,x3,x4])=f(f(f(x1,x2),x3),x4)

>>>from functools import reduce
>>>def add (x,y):
...     return x+y
...
>>>reduce(add,[1,3,5,7,9])
25

#把序列[1,3,5,7,9]变换成整数13579
>>>from functools import reduce
>>>def fn(x,y):
...     return x*10+y
...
>>>reduce(fn,[1,3,5,7,9])
13579

#str转换为int函数
>>> def str2int(s):
...     def fn(x,y):
...             return x*10+y
...     def char2num(s):
...             return {'0':1,'1':1,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9}[s]
...     return reduce(fn,map(char2num,s))
>>>str2int('345')
345

#filter()把传入的函数依次作用于每个元素，根据返回值是True还是false决定保留还是丢弃该元素
def is_odd(n):
    return n%2==1
list(filter(is_odd,[1,2,3,4,5,6,7,8,9]))
#结果：[1,3,5,7,9]

#注意：filter()函数返回的是一个Iterator,也就是一个惰性序列，所以要强迫filter()完成计算

#排序算法
>>>sorted([36,5,-12,9,-21])
[-21,-12,5,9,36]

#sorted()函数是高阶函数，它可以接受一个key函数来实现自定义的排序
>>>sorted([36,5,-12,9,-21],key=abs)
[5,9,-12,-21,36]

#默认情况下，对字符串的排序，是按照ASICII的大小比较的，由于'Z'<'a'，所以大写字母Z排在小写字母a的前面
>>>sorted(['bob','about','Zoo','Credit'])
['Credit','Zoo','about','bob']

#我们给sorted传入key函数，即可实现忽略大小写的排序
>>>sorted(['bob','about','Zoo','Credit'],key=str.lower)
['about','bob','Credit','Zoo']

#要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True
>>>sorted(['bob','about','Zoo','Credit'],key=str.lower,reverse=True)
['Zoo','Credit','bob','about']

#函数作为返回值
def lazy_sum(*args):
    def sum():
        ax=0
        for n in args
            ax=ax+n
        return ax
    return sum     #此处把函数作为返回值
 
>>>f=lazy_sum(1,3,5,7,9)
>>>f
<function lazy_sum.<locals>.sum at 0x1022ef630>
>>>f()
25

#在这个例子中，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，即“闭包”
#注意：当调用lazy_sum()时，每次都会返回一个新的函数，即使传入相同的参数
>>>f1=lazy_sum(1,3,5,7,9)
>>>f2=lazy_sum(1,3,5,7,9)
>>>f1=f2
False
#f1和f2的调用结果互不影响

#闭包
def count():
    fs=[]
    for i in range(1,4):
        def f():
            return i*i
        return fs.append(f)
    return fs
    
f1,f2,f3=count()
>>>f1
9
>>>f2
9
>>>f3
9

#调用f1,f2,f3后结果都是9，原因是返回的函数引用了变量i，但它并非立即执行。等到3个函数都返回时，i变为了3，故结果是9

#返回闭包时注意：返回函数不用引用任何循环变量，或者后续会发生变化的变量
#如果一定要引用循环变量，就创建一个函数，用该函数的参数绑定循环变量当前的值，无论循环变量后续如何更改，已绑定到函数参数的值不变
def count():
    def f(j):
        def g():
            return j*j
        return g
    fs=[]
    for i in range(1,4):
        fs.append(f(i)) #f(i)立即被执行，因此i的当前值被传入f()
    return fs
>>>f1,f2,f3=count()
>>>f1()
1
>>>f2()
4
>>>f3()
9

#小结：
#一个函数可以返回一个计算结果，也可以返回一个函数
#返回一个函数时，牢记该函数并未执行，返回函数中不用引用任何可能会变化的变量

#匿名函数,lambda x:x*x 其中冒号前面的x是参数，后面是表达式，不用写return
>>>list(map(lambda x:x*x,[1,2,3,4,5,6,7,8,9]))
[1,4,9,16,25,36,49,64,81]

>>>def now():
    print('2015-3-25')
    
>>>f=now
>>>f()
2015-3-25

#函数对象有一个_name_属性，可以拿到函数的名字
>>>now._name_
'now'
>>>f._name_
'now'

#在代码运行期间动态增加功能而不更改函数的原有实现的方式，称之为“装饰器”(Decorator)
def log(func):
    def wrapper(*args,**kw):
        print ('call %s():'% func._name_)
        return func(*args,**kw)
    return wrapper
    
#观察上面的log，就是一个decorator，接受一个函数作为参数，并返回一个函数
#借助Python的@语法，把decorator置于函数的定义处：
@log
def now():
    print ('2015-3-25')
>>>now()
call new():
2015-3-25

def log(text):
    def decorator(func):
        def wrapper(*args,**kw):
            print('%s %s():'% (text,func._name_))
            return func(*args,**kw)
        return wrapper
    return decorator
    
@log('execute')
def now():
    print('2015-3-25')
    
>>>now()
execute now():
2015-3-25

>>>now =log('execute')(now) #首先执行log('execute')返回decorator函数，再把now函数作为参数传入decorator函数，返回wrapper函数

#一个完整的decorator的写法如下：
import functools

def log(func):
    @functools.wraps(func)  #等同于wrapper._name_=func._name_
    def wrapper(*args,**kw):
        print('call %s():'% func._name_)
        return func(*args,**kw)
    return wrapper
    
#带参数的decorator
import functools
def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args,**kw):
            print('%s %s():'%(text,func._name_))
            return func(*args,**kw)
        return wrapper
    return decorator

#import functools是导入functools模块

#偏函数，functools.partial就是帮助我们创建一个偏函数，其作业是把一个函数的某些参数固定住，返回一个新函数
>>>import functools
>>>int2=functools.partial(int,base=2)
>>>int2('1000000')
64

>>>max2=functools.partial(max,10)
>>>max2(5,6,7)
10

#当函数的参数太多时，需要简化，使用functools.partial可以创建一个新函数，从而调用更简单

--模块
>>>import sys #使用sys模块
#类似__xxx__的变量是特殊变量，可以被直接引用，但是有特殊用途，如__author__,__name__
#类似_xxx和__xxx的变量就是非公开的变量(private)，不应该被直接引用
#安装第三方模块：pip install Pillow ，其中Pillow为第三方图像处理工具库
>>>from PIL import Image
>>>im=Image.open('test.png')
>>>print(im.format,im.size,im.mode)
PNG (400,300) RGB
>>>im.thumbnail((200,100))
>>>im.save('thumb.jpg','JPEG')
#常用的第三方库还有MySQL的驱动：mysql-connector-python，用于科学计算的NumPy库：numpy，用于生成文本的模板工具JinJa2
#搜索路径存放在sys模块的path变量中

#添加自己的搜索目录，有两种方法
#方法一：直接修改sys.path，添加要搜索的目录
>>>import sys
>>>sys.path.append('/Users/michael/my_py_scripts')
#方法二：设置环境变量PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中。设置方法与设置Path环境变量类似


--面向对象编程
class Student(object):   #object表示父类
    pass
#可以自由给实例变量绑定属性
>>>bart=Student()
>>>bart.name='Bart Simpson'
>>>bart.name
'Bart Simpson'

class Student(object):
    def __init__(self,name,score):  #第一个参数永远是self，表示创建的实例本身
        self.name=name
        self.score=score
>>>bart=Student('Bart Simpson',59)  #创建实例时，不能传入空的参数，必须传入与__init__方法匹配的参数，但self不需要传
>>>bart.name
'Bart Simpson'
>>>bart.score
59

#类中函数和普通参数相比：类中函数第一个参数永远是实例变量self，调用时不用传递该参数，其他都是一样

#数据封装
class Student(object):
    def __init__(self,name,score):  #第一个参数永远是self，表示创建的实例本身
        self.name=name
        self.score=score    
    def print_score(self):          #定义一个方法，第一个参数是self，其他和普通函数一样，调用时直接调用，self不用传递，其他参数正常传入
        print('%s:$s'%(self.name,self.score))
        
#访问限制
#如果让内部属性不被外部访问，可以在属性的名称前面加上两个下划线__
#python中，实例的变量名如果以__开头，就变成了一个私有变量(private)，只有内部可以访问，外部不能访问

#继承和多态
#继承可以把父类的所有功能都直接拿过来，子类只需新增自己特有的方法，也可以把父类方法覆盖重写
#Python是动态语言，则不一定需要传入Animal类型，我们只要保证传入的对象有一个run()方法就可以了
#动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的

#获取对象信息
#方法一：使用type()函数，type()返回的是对于的Class类型
#判断一个对象是否是函数，可以使用types模块中定义的常量
>>>import types
>>>def fn():
...     pass
...
>>>type(fn)==types.FunctionType
True
>>>type(abs)==types.BuiltinFunctionType
True
>>>type(lambda x:x)==types.LambdaType
True
>>>type((x for x in range(10)))==types.GeneratorType
True

#方法二：使用isinstance()
>>>h=Husky()
>>>isinstance(h,Husky)
True
>>>isinstance(h,Dog)
True
#isinstance()判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上
#能使用type()判断的基本类型也可以用isinstance()判断

#isinstance()还可以判断一个变量是否是某些类型中的一种
>>>isinstance([1,2,3],(list,tuple))
True

#方法三：使用dir()
#dir()用于获取对象的所有属性和方法，它返回一个包含字符串的list
>>>len('ABC')
3
>>>'ABC'.__len__()  #与len('ABC')等价
3

>>>class MyObject(object):
...     def __init__(self):
...         self.x=9
...     def power(self):
...         return self.x*self.x
...
>>>obj=MyObject()
>>>hasattr(obj,'x') #有属性'x'吗？
True
>>>hasattr(obj,'y') #有属性'y'吗？
False
>>>setattr(obj,'y',19) #设置属性'y'的值为19
>>>hasattr(obj,'y')
True
>>>getattr(obj,'y') #获取属性'y'
19
>>>getattr(obj,'z') #获取不存在的属性'z'，则会报错
>>>getattr(obj,'z',404)  #如果不存在'z'，返回默认值404
404

#也可以获取对象的方法
>>>hasattr(obj,'power')  #有‘power’方法吗？

#实例属性和类属性
#实例属性的优先级高于类属性
#注意：在编写程序时，实例属性和类属性不能用相同的名字，因为相同名称的实例属性会屏蔽掉类属性，
#但是当你删除实例属性时，再次使用相同的名称，访问的将是类的属性

--面向对象高级编程
#Python中对一个实例绑定的方法对另外一个实例不起作用
#为了给所有实例绑定方法，可以给class绑定方法
class Student(object):
    pass
def set_score(self,score):
...     self.score=score
...
>>>Student.set_score=MethodType(set_score,Student)  #给class绑定方法

#使用__slots__，可以限制class实例能添加的属性
class Student(object):
    __slots__=('name','age')  #用tuple定义允许绑定的属性名称
    
#使用__slots__定义的属性仅对当前类实例起作用，对继承的子类不起作用

#使用@property,可以把一个方法变为属性调用
class Student(object):
    @property
    def score(self):
        return self.score
    @score.setter
    def score(self,value):
        if not isinstance(value,int):
            raise ValueError('score must be an integer')
        if value <0 or value>100:
            raise ValueError('score must between 0-100!')
        self.score=value
>>>s=Student()
>>>s.core=60 #OK，实际转化为s.set_score(60)
>>>s.core    #实际转化为s.get_score()
60
>>>s.score=999
Traceback(most recent call last):
...
ValueError:score must between 0-100!

#多重继承
#通过多重继承，一个子类可以同时获得多个父类的所有功能
class Dog(Mammal,Runnable):   #狗类多继承哺乳类和能跑类
    pass
class Bat(Mammal,Flyable):    #蝙蝠类多继承哺乳类和能飞类
    pass
    
#MixIn的目的就是给一个类增加多个功能，这样，类设计时，我们优先考虑通过过继承来组合多个MixIn的功能，而不是设计多层次的复杂继承关系


#定制类
#__str__()返回用户看到的字符串
>>>class Student(object):
...     def __init__(self,name):
...         self.name=name
...     def __str__(self):
...         return 'Student object (name:%s)'% self.name
...

>>>print(Student('Michael'))
Student object (name:Michael)

>>>s=Student('Michael')  #直接敲变量不用print，打印出来的实例还是不好看，这是因为直接显示变量调用的是__repr__()
>>>s
<__main__.Student object at 0x1022ef630>

#__repr__
#返回程序开发者看到的字符串，是为调试服务的
class Student(object):
    def __init__(self,name):
        self.name=name
    def __str__(self):
        return 'Student object (name=%s)'%self.name
    __repr__=__str__
    
#__iter__
#如果一个类想被用于for...in循环，就必须实现一个__iter__()方法，该方法返回一个迭代对象
#然后，Pytho的for循环会不断调用该迭代对象的__next__()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环
class Fib(object):
    def __init__(self):
        self.a,self.b=0,1   #初始化两个计数器a,b
    def __iter__(self):
        return self         #实例本身就是迭代对象，故返回自己
        
    def __next__(self):
        self.a,self.b=self.b,self.a+self.b #计算下一个值
        if self.a>100:  #退出循环条件
            raise StopIteration();
        return self.a       #返回下一个值
        
>>>for n in Fib():
...    print(n)
...


#__getitem__
#可以使Fib()像list那样按照下标取出元素，需要实现该方法
class Fib(object):
    def __getitem__(self,n):
        a,b=1,1
        for x in range(n):
            a,b=b,a+b
        return a
#现在可以按照下标访问数列的任意一项了
#但是list有一个神奇的切片方法，对于Fib却报错。原因是__getitem__传入的可能是一个int，也可能是一个切片对象slice，所以要做判断
class Fib(object):
    def __getitem__(self,n):
        if isinstance(n,int):  #n是索引
            a,b=1,1
            for x in range(n):
                a,b=b,a+b
            return a
        if isinstance(n,slice): #n是切片
            start=n.start
            stop=n.stop
            if start is None:
                start=0
            a,b=1,1
            L=[]
            for x in range(stop):
                if x>=start:
                    L.append(a)
                a,b=b,a+b
            return L
#现在Fib()拥有了切片功能

#与之对应的__setitem__()方法，把对象视作list或dic来对集合赋值，还有__delitem__()方法，用于删除某个元素
#总之通过以上方法，我们可以的类表现得和Python自带的list、tuple、dict没有什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口

#__getattr__
#在没有找到属性的情况下，才会调用该方法，要让class只相应特定的几个属性，我们就按照约定，抛出AttributerError的错误
#使用__getattr__可以写出一个链式调用
class Chain(object):
    def __init__(self,path=''):
        self._path=path
    def __getattr__(self,path):
        return Chain('%s/%s'%(self._path,path))
    def __str__(self):
        return self._path
    __repr__=__str__
    
>>>Chain().status.user.timeline.list
'/status/user/timeline/list'
#这样无论API怎么变，SDK都可以根据URL实现完全动态的调用，而且，不随API的增加而改变

#__call__
#只需要定义__call__方法，就可以直接对实例进行调用
class Student(object):
    def __init__(self,name):
        self.name=name
    def __call__(self):
        print('My name is %s'%self.name)
>>>s=Student('Michael')
>>>s()   #self参数不用传递
My name is Michael

#通过callable()函数，我们可以判断一个对象是否是“可调用”对象

#type()
#type()函数可以查看一个类型或变量的类型，还可以动态创建出新的类型，如：
>>>def = fn(self,name='world'):   #先定义函数
...     print('Hello,%s.'%name)
...
>>>Hello=type('Hello',(object,),dict(hello=fu))  #创建Hello class
>>>h=Hello()
>>>h.hello()
Hello,world.
>>>print(type(Hello))
<class 'type'>
>>>print(type(h))
<class '__main__.Hello'>
#要创建一个class对象，type()函数依次传入3个参数
#1.class的名称
#2.继承的父类集合，注意python支持多继承，如果只有一个父类，别忘了tuple的单元素写法；
#3.class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上

#metaclass
#元类，如果想创建出类，必须根据metaclass 创建出类，即：先定义metaclass，就可以创建类，最后创建实例（太强大，搞不懂）

#错误处理
#捕获错误：try... except... finally...
#抛出错误：raise

#程序调试
#方法一：可以使用print()
#方法二：使用assert()
    #如果程序中到处充斥着assert()，启动Python时，可以用-0参数关闭assert，关闭后，所有的assert相当于pass
#方法三：使用logging,logging.info()可以输出一段文本。
import logging
logging.basicConfig(level=logging.INFO)
    #添加以上配置才能显示详细信息
    #这就是logging的好处，它允许你指定记录信息的级别，有debug，info,warning，error等几个级别
#方法四：pdb
    #以参数-m pbd启动后，输入命令n可以单步执行代码，任何时候可以输入（p 变量名）来查看变量，输入命令q结束调试，退出程序
#方法五：pbd.set_trace()
    #需要import pdb，然后在可能出错的地方放一个pbd.set_trace()，就可以设置一个断点
#推荐使用的调试工具是：PyCharm


#IO编程
#读文件，使用Python内置的open()函数
>>>f=open('/users/michael/my_py_scripts','r')   #标识符'r'表示读，如果文件不存在就会抛出IOError的错误
#Python引入了with语句来自动帮我们调用close()方法
with open('.\111.txt','r') as f:
    print(f.read())
    
#如果文件很小，read()一次性读取最方便，如果不能确定文件，大小反复调用read(size)，如果是配置文件，调用readlines()最方便
for line in f.readlines():
    print(line.strip())   #把末尾的'\n'删除

#二进制文件
>>>f=open('.\111.txt','rb')
>>>f.read()

#字符编码
>>>f=open('.\111.txt','r',encoding='gbk')
>>>f.read()

>>>f=open('.\111.txt','r',encoding='gbk',errors='ignore')

#写文件
>>>f=open('.\111.txt','w')

#StringIO
#StringIO就是在内存中读写str
#要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可
>>>from io import StringIO
>>>f=StringIO()
>>>f.write('hello')
5
>>>print(f.getvalue())   #getvalue()用于获得写入后的str
hello

#读取StringIO
>>>from io import StringIO
>>>f=StringIO('Hello!\nHi!\nGoodbye!')
>>>while True:
...     s=f.readline()
...     if s=='':
...         break
...     print(s.strip())
...
Hello!
Hi!
Goodbye!

#BytesIO
#StringIO操作只能是str，如果要操作二进制数据，需要使用BytesIO
#BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes
>>>from io import BytesIO
>>>f=BytesIO()
>>>f.write('中文',encode('utf-8'))
6
>>>print(f.getvalue())

#Python内置os模块调用操作系统提供的接口函数
#os.environ能获取环境变量
#os.environ.get('key'),获取环境变量的某一个值

#查看当前目录的绝对路径
>>>os.path.abspath('.')
#在某个目录下创建一个新目录，首先把新目录的完整路径表示出来
>>>os.path.join('/Users/michael','testdir')
'/Users/michael/testdir'
#创建一个目录
>>>os.mkdir('Users/michael/testdir')
#删除一个目录
>>>os.rmdir('Users/michael/testdir')

#合并路径用os.path.join(),拆分路径用os.path.split()函数，os.path.splitext()可以拆分得到扩展名

#对文件重命名
>>>os.rename('test.txt','test.py')
#删除文件
>>>os.remove('test.py')

#shutil模块提供了copyfile()函数，可以看做是os模块的补充

#序列号(pickling)，反序列化(unpickling)
#Python提供了pickle模块来实现序列化
>>>import pickle
>>>d=dict(name='Bob',age=20,score=88)
>>>pickle.dumps(d)  #pickle.dump()方法把任意对象序列化为一个bytes，然后就可以把这个bytes写入文件

>>>f=open('dump.txt','wb')
>>>pickle.dumps(d,f)  #把对象序列化后写入一个file-like Object
>>>f.close()

#可以先把内容读到一个bytes，然后用pickle.loads()方法反序列化出对象
>>>f=open('dump.txt','rb')
>>>d=pickle.loads(f)
>>>f.close()
>>>d
{'age':20,'score':88,'name':Bob}

>>>import json
>>>d=dict(name='Bob',age=20,score=88)
>>>json.dumps(d)     #序列化为json对象
'{'age':20,'score':88,'name':Bob}'

>>>json_str='{'age':20,'score':88,'name':Bob}'
>>>json.loads(json_str)    #json反序列化
{'age':20,'score':88,'name':Bob}

#对class的序列化和反序列化
import json
class Student(object):
    def __init__(self,name,age,score):
        self._name_=name
        self._age=age
        self._score=score
    def student2dict(std):
        return {'name':name,'age':age,'score':score}

>>>s=Student('Bob',20,88)
>>>print(json.dumps(s,default=student2dict))  #可选参数default就是把任意对象变成一个可序列化json的对象
{'age':20,'score':88,'name':Bob}

>>>print(json.dumps(s,default=lambda obj:obj.__dict__))  #偷懒写法，把任意class实例变为dict

def dict2student(d):
    return Student(d['name'],d['age'],d['score'])
>>>print(json.loads(json_str,object_hook=dict2student))   #反序列化

--进程和线程
#在Unix/Linux下，可以使用fork()调用实现多进程
    #fork()调用一次，返回两次，因为操作系统自动把当前进程(父进程)复制了一份(子进程)，然后，分别在父进程和子进程内返回
    #子进程永远返回0，而父进程返回子进程的ID，子进程可调用getppid()就可以拿到父进程的ID
#要实现跨平台的多进程，可以使用multiprocessing模块
#进程间通信使用Queue、Pipes等实现的

#Python的标准库提供了两个模块：_thread和threading,_thread是低级模块，threading是高级模块，绝大多情况用threading模块
import time,threading
#新线程执行的代码
def loop():
    print('thread %s is running...'%threading.current_thread().name)
    n=0
    while n<5:
        n=n+1
        print('thread %s>>>%s'%(threading.current_thread().name,n))
        time.sleep(1)
    print('thread %s ended...'%threading.current_thread().name)
    
print('thread %s is running...'%threading.current_thread().name)
t=threading.Thread(target=loop,name='LoopThread')
t.start()
t.join()
print('thread %s ended.'%threading.current_thread().name)

#threading模块有个current_thread()函数，返回当前线程实例
balance=0
lock=threading.Lock()
def run_thread(n):
    for i in range(100000):
        #先要获取锁
        lock.acquire()
        try:
            #放心的改变吧
            change_it(n)
        finally:
            #改完了一定要释放锁
            lock.release()
            
            
#ThreadLocal
import threading
#创建全局ThreadLocal对象
local_school=threading.local()
....
#全局变量local_school就是一个ThreadLocal对象，每个Thread对它都可以读取，但互不影响。
#ThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等

#分布式进程
#在Thread和Process中，应当优选Process，因为Process更稳定。
#Process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上。

--正则表达式
#在正则表达式中\d可以匹配一个数字，\w可以匹配一个字母或数字
#.可以匹配任意字符，
#*表示任意个字符（包括0个），+表示至少一个字符，？表示0个或1个字符，用{n}表示n个字符，用{n,m}表示n-m个字符
#复杂的例子：\d{3}\s+\d{3,8}
#从左到右解读
    #1.\d{3}表示匹配3个数字，例如'010'
    #2.\s可以匹配一个空格（包括Tab等空白符），所以\s+表示至少有一个空格，例如' ','  '等
    #3.\d{3,8}表示3-8个数字，例如'1234567'

#更精准的匹配，可以用[]表示范围，例如：
    #[0-9a-zA-Z\_]可以匹配一个数字，字母或者下划线，_是特殊字符需要用\进行转义
    #[0-9a-zA-Z\_]+匹配至少由一个数字，字母或者下划线组成的字符串，比如'a100','0_Z','Py300'
    #[a-zA-Z\_][0-9a-zA-Z\_]*匹配字母或者下划线开头，后接任意数字、字母或者下划线组成的字符串
    #[a-zA-Z\_][0-9a-zA-Z\_]{0,19}更精确的限制了变量字符串是1-20个字符
#A|B可以匹配A或者B，如[P|p]ython可以匹配‘Python’或者'python'
#^表示行的开头，^/d表示必须以数字开头
#$表示行的结尾，$/d表示必须以数字结尾

#Python提供re模块，使用正则表达式
>>>import re
>>>re.match(r'^\d{3}\-\d{3,8}$','010-12345')   #使用r前缀后就不用考虑使用转义的问题了
<_sre.SRE_Match object; span=(0, 9), match='010-12345'>   #匹配成功,返回一个Match对象
>>> re.match(r'^\d{3}\-\d{3,8}$','010-123456789')         #匹配失败，返回None
>>>

#常见的判断方法
>>> test='abd'
>>> if re.match(r'abcde',test):
...       print('ok')
... else:
...       print('failed')
...
failed

#切分字符串
>>> 'a b   c'.split(' ')
['a', 'b', '', '', 'c']

#使用正则表达式进行切分
>>> re.split(r'\s+','a b   c')
['a', 'b', 'c']

>>> re.split(r'[\s\,]+','a b  ,c d')
['a', 'b', 'c', 'd']

>>> re.split(r'[\s\,\;]+','a b; ; ;  ,c d')
['a', 'b', 'c', 'd']

#分组，正则表达式还有提取子串的强大功能。用()表示的就是提取的分组(Group)
>>> re.match(r'^\d{3}\-\d{3,8}$','010-12345678')
<_sre.SRE_Match object; span=(0, 12), match='010-12345678'>
>>> m=re.match(r'^(\d{3})-(\d{3,8})$','010-12345')
>>> m
<_sre.SRE_Match object; span=(0, 9), match='010-12345'>
>>> m.groups()
('010', '12345')
>>> m.group(0)
'010-12345'
>>> m.group(1)
'010'
>>> m.group(2)
'12345'
#注意：group(0)永远是原始字符串，group(1)、group(2)...表示第1、2、...个字符串

#贪婪匹配，正则表达式模式是贪婪匹配，也就是匹配尽可能多的字符
>>> re.match(r'^(\d+)(0*)$','102300').groups()
('102300', '')
#非贪婪匹配，加?可以进行非贪婪匹配
>>> re.match(r'^(\d+?)(0*)$','102300').groups()
('1023', '00')

#当我们在Python中使用正则表达式时，re模块内部会干两件事情：
    #1.编译正则表达式，如果正则表达式的字符串本身不合法，会报错；
    #2.用编译后的正则表达式去匹配字符串
#如果一个正则表达式要重复使用几千次，出于效率考虑，我们可以预编译该正则表达式，然后在匹配
import re
#编译：
>>> re_telephone=re.compile(r'(^\d{3})\-(\d{3,8}$)')
#使用：
>>> re_telephone.match('010-12345').groups()
('010', '12345')
>>> re_telephone.match('010-188835').groups()
('010', '188835')
