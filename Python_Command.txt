#!/usr/bin/env python3
# -*- coding: utf-8 -*-

--Python基础
print("hello world")
classmates=['Michael','Bob','Tracy']
len(classmates)
classmates[0]
classmates[-1]  #获取倒数第一个元素
classmates[-2]  #获取倒数第二个元素
classmates.append('Adam')
classmates.insert(1,'Jack')
classmates.pop()  #删除末尾元素
classmates.pop(1) #删除指定位置的元素
L=['Apple',123,True]  #list里面的元素的数据类型可以不同
s=['python','java',['asp','php'],'scheme']  #list里面可以是另一个list

t=(1,2)  #定义一个tuple，其元素必须确定下来
t=(1)   t=(1,)   #区别:第一个是数学公式，第二个才是1个元素的tuple
t=('a','b',['A','B'])

age=3
if age>=18:
   print('your age is',age)
   print('adult')
else:
   print('your age is',age)
   print('teenager')

names=['Michael','Bob','Tracy']
for name in names:
    print(name)
	
for i in range(1, 10) :
    for j in range(1, i+1) :
        print(j, 'x', i, '=', j*i, '\t',)
    print('\n')
	
d={'Michael':95,'Bob':75,'Tracy':85}
d['Jack']=98
'Thomas' in d #判断Thomas是否在d中
d.get('Thomas') #如果不存在，返还None
d.get('Thomas',-1) #如果不存在，返还指定的-1
d.pop('Bob')
s=set([1,2,3])

--函数
def my_abs(x):
   if not isinstance(x,(int,float)):    #参数检查
      raise TypeError('bad operand type')
   if x>=0:
     return x
   else:
     return -x
	 
from abstest import my_abs  #从文件abstest中导入my_abs函数，注意abstest没有.py后缀

def pop():
    pass
	
import math
def move(x,y,step,angle=0):
    nx=x+step*math.cos(angle)
	ny=y-step*math.sin(angle)
	return nx,ny
    
#位置参数
def enroll(name,gender,age=6,city='Beijing'):
    print('name:',name)
    print('gender:',gender)
    print('age:',age)
    print('city:',city)
    
#可变参数，函数内部参数numbers接收到的是一个tuple
def calc(*numbers):
    sum=0
    for n in numbers:
        sum=sum+n*n
    return sum
    
#关键字参数，函数内部参数kw接收到的是一个dict
def person(name,age,**kw):
    print('name:',name,'age:',age,'Other:',kw)
    
>>>extra={'city':'Beijing','Job':'Engineer'}
>>>person('Jack',24,city=extra['city'],Job=extra['Job'])
>>>person('Jack',24,**extra)
name:Jack age:24 other:{'city':'Beijing','Job':'Engineer'}
def person(name,age,**kw):
    if 'city' in kw:
        #有city参数
    if 'Job' in kw:
        #有Job参数
    print('name:',name,'age:',age,'Other:',kw)

#命名关键字参数,*后面的参数被视为命名关键字参数
#命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错
def person(name,age,*,city,job):
    print(name,age,city,job)
#命名关键字参数可以有缺失值，调用时，可不传入city参数
def person(name,age,*,city='Beijing',job)
    print(name,age,city,job)
    
#五种参数：必选参数，默认参数，可变参数，关键字参数，命名关键字参数
#除了可变参数无法和命名关键字参数混合使用，其他可以组合使用
#参数定义的顺序必须是：必选参数，默认参数，可变参数/命名关键字参数和关键字参数，如下：
def fl(a,b,c=0,*args,**kw):
    print('a=',a,'b=',b,'c=',c,'args=',args,'kw=',kw)
def f2(a,b,c=0,*,d,**kw):
    print('a=',a,'b=',b,'c=',c,'args=',args,'kw=',kw)

#小结
#*args是可变参数，args接收的是一个tuple;
#**kw是关键字参数，kw接收的是一个dict

#递归函数
def fact(n):
        if n==1:
            return 1
        else:
            return n*fact(n-1)
            
 #尾递归

def fact(n):
    return fact_iter(n,1)

def fact_iter(num,product):
    if num==1:
        return product
    return fact_iter(num-1,num*product)
	
--高级特性
>>>L=['Michael','Sarah','Tracy','Bob','Jack']
>>>L[0:3]   #切片：从索引0开始取，直到索引3为止，但不包括索引3
>>>L[:3]    #同上，简写方式
>>>L[-2:]             ['Bob','Jack']
>>>L[-2:-1]           ['Bob']

>>>L=list(range(100))
>>>L[:10:2]    #前10个数，每两个取一个
[0,2,4,6,8]
>>>L[::5]      #所有数，每5个取一个
[0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95]

#默认情况下，dict迭代的是key。如果迭代value，可以用for value in d.values()，如果同时迭代key和value，可以使用for k,v in d.items()

#Python内置的enumerate函数可以把一个list变成索引-元素对，如下：
>>>for i ,value in enumerate(['A','B','C']):
...     print(i,value)
...
0 A
1 B
2 C

>>>for x,y in [(1,1),(2,4),(3,9)]:
...     print(x,y)
...
1 1
2 4
3 9

#列表生成式
>>>[X * X for X in range(1,11)]
[1,4,9,16,25,36,49,64,81,100]

>>>[X * X for X in range(1,11) if X % 2==0]
[4,16,36,64,100]

>>>[m + n for m in 'ABC' for n in 'XYZ']
['AX','AY','AZ','BX','BY','BZ','CX','CY','CZ']

#生成器(generator)
#方法一，将一个列表生成式的[]改成()，就创建了一个generator
>>>L=[x*x for x in range(10)]
>>>L
[0,1,4,9,16,25,36,49,64,81]
>>>g=(x*x for x in range(10))
>>>g
<generator object<genexpr> at 0x1022ef630>

#方法二，函数定义中包含yield关键字就不是普通的函数，而是一个generator
#斐波拉契数列generator
def fib(max):
    n,a,b=0,0,1
    while n<max:
        yield b
        a,b=b,a+b
        n=n+1
    return 'done'
    
#注意区分普通函数和generator函数，普通函数调用直接返回结果
>>>r=abs(6)
>>>r
6
#generator函数的“调用”实际返回一个generator对象
>>>g=fib(6)
>>>g
<generator object fib at 0x1022ef948>

#可直接作用于for循环的数据类型有以下几种
#一类是集合数据类型，如list、tuple、dict、set、str等：
#一类是generator，包括生成器和带yield的generator function
#这些可以直接作用于for循环的对象统称为可迭代对象:Iterable
#可以用isinstance()判断一个对象是否是Iterable对象

#可以被next()函数调用并不断返还下一个值的对象称为迭代器：Iterator
#可以用isinstance()判断一个对象是否是Iterator对象

#生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator
#把list、dict、str等Iterable变成Iterator可以使用iter()函数

--函数式编程
#变量可以指向函数
>>>f=abs
>>>f(-10)
10
#函数名也是变量
>>>abs=10
>>>abs(-10)
Traceback(most recent call last):
    File "<stdin>",line 1,in <module>
TypeError:'int' object is not callable
#传入函数
def add(x,y,f):
    return f(x)+f(y)
>>>add(-5,6,abs)  #第三个传入的是abs()函数，abs(-5)+abs(6)=11
11  

#高阶函数 map()
#map()传入的第一个参数是f,即函数对象本身，由于结果r是一个Iterator,
#Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list
>>>def f(x):
...     return x*x
...
>>>r=map(f,[1,2,3,4,5,6,7,8,9])
>>>list(r)
[1,4,9,16,25,36,49,64,81]

>>>list(map(str,[1,2,3,4]))
['1','2','3','4']

#reduce()把一个函数作用在序列[x1,x2,x3,...]上，这个函数必须接收两个参数
#reduce把结果继续和序列的下一个元素做累积计算，其效果如下：
reduce(f,[x1,x1,x3,x4])=f(f(f(x1,x2),x3),x4)

>>>from functools import reduce
>>>def add (x,y):
...     return x+y
...
>>>reduce(add,[1,3,5,7,9])
25

#把序列[1,3,5,7,9]变换成整数13579
>>>from functools import reduce
>>>def fn(x,y):
...     return x*10+y
...
>>>reduce(fn,[1,3,5,7,9])
13579

#str转换为int函数
>>> def str2int(s):
...     def fn(x,y):
...             return x*10+y
...     def char2num(s):
...             return {'0':1,'1':1,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9}[s]
...     return reduce(fn,map(char2num,s))
>>>str2int('345')
345

#filter()把传入的函数依次作用于每个元素，根据返回值是True还是false决定保留还是丢弃该元素
def is_odd(n):
    return n%2==1
list(filter(is_odd,[1,2,3,4,5,6,7,8,9]))
#结果：[1,3,5,7,9]

#注意：filter()函数返回的是一个Iterator,也就是一个惰性序列，所以要强迫filter()完成计算

#排序算法
>>>sorted([36,5,-12,9,-21])
[-21,-12,5,9,36]

#sorted()函数是高阶函数，它可以接受一个key函数来实现自定义的排序
>>>sorted([36,5,-12,9,-21],key=abs)
[5,9,-12,-21,36]

#默认情况下，对字符串的排序，是按照ASICII的大小比较的，由于'Z'<'a'，所以大写字母Z排在小写字母a的前面
>>>sorted(['bob','about','Zoo','Credit'])
['Credit','Zoo','about','bob']

#我们给sorted传入key函数，即可实现忽略大小写的排序
>>>sorted(['bob','about','Zoo','Credit'],key=str.lower)
['about','bob','Credit','Zoo']

#要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True
>>>sorted(['bob','about','Zoo','Credit'],key=str.lower,reverse=True)
['Zoo','Credit','bob','about']

#函数作为返回值
def lazy_sum(*args):
    def sum():
        ax=0
        for n in args
            ax=ax+n
        return ax
    return sum     #此处把函数作为返回值
 
>>>f=lazy_sum(1,3,5,7,9)
>>>f
<function lazy_sum.<locals>.sum at 0x1022ef630>
>>>f()
25

#在这个例子中，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，即“闭包”
#注意：当调用lazy_sum()时，每次都会返回一个新的函数，即使传入相同的参数
>>>f1=lazy_sum(1,3,5,7,9)
>>>f2=lazy_sum(1,3,5,7,9)
>>>f1=f2
False
#f1和f2的调用结果互不影响

#闭包
def count():
    fs=[]
    for i in range(1,4):
        def f():
            return i*i
        return fs.append(f)
    return fs
    
f1,f2,f3=count()
>>>f1
9
>>>f2
9
>>>f3
9

#调用f1,f2,f3后结果都是9，原因是返回的函数引用了变量i，但它并非立即执行。等到3个函数都返回时，i变为了3，故结果是9

#返回闭包时注意：返回函数不用引用任何循环变量，或者后续会发生变化的变量
#如果一定要引用循环变量，就创建一个函数，用该函数的参数绑定循环变量当前的值，无论循环变量后续如何更改，已绑定到函数参数的值不变
def count():
    def f(j):
        def g():
            return j*j
        return g
    fs=[]
    for i in range(1,4):
        fs.append(f(i)) #f(i)立即被执行，因此i的当前值被传入f()
    return fs
>>>f1,f2,f3=count()
>>>f1()
1
>>>f2()
4
>>>f3()
9

#小结：
#一个函数可以返回一个计算结果，也可以返回一个函数
#返回一个函数时，牢记该函数并未执行，返回函数中不用引用任何可能会变化的变量

#匿名函数,lambda x:x*x 其中冒号前面的x是参数，后面是表达式，不用写return
>>>list(map(lambda x:x*x,[1,2,3,4,5,6,7,8,9]))
[1,4,9,16,25,36,49,64,81]

>>>def now():
    print('2015-3-25')
    
>>>f=now
>>>f()
2015-3-25

#函数对象有一个_name_属性，可以拿到函数的名字
>>>now._name_
'now'
>>>f._name_
'now'

#在代码运行期间动态增加功能而不更改函数的原有实现的方式，称之为“装饰器”(Decorator)
def log(func):
    def wrapper(*args,**kw):
        print ('call %s():'% func._name_)
        return func(*args,**kw)
    return wrapper
    
#观察上面的log，就是一个decorator，接受一个函数作为参数，并返回一个函数
#借助Python的@语法，把decorator置于函数的定义处：
@log
def now():
    print ('2015-3-25')
>>>now()
call new():
2015-3-25

def log(text):
    def decorator(func):
        def wrapper(*args,**kw):
            print('%s %s():'% (text,func._name_))
            return func(*args,**kw)
        return wrapper
    return decorator
    
@log('execute')
def now():
    print('2015-3-25')
    
>>>now()
execute now():
2015-3-25

>>>now =log('execute')(now) #首先执行log('execute')返回decorator函数，再把now函数作为参数传入decorator函数，返回wrapper函数

#一个完整的decorator的写法如下：
import functools

def log(func):
    @functools.wraps(func)  #等同于wrapper._name_=func._name_
    def wrapper(*args,**kw):
        print('call %s():'% func._name_)
        return func(*args,**kw)
    return wrapper
    
#带参数的decorator
import functools
def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args,**kw):
            print('%s %s():'%(text,func._name_))
            return func(*args,**kw)
        return wrapper
    return decorator

#import functools是导入functools模块

#偏函数，functools.partial就是帮助我们创建一个偏函数，其作业是把一个函数的某些参数固定住，返回一个新函数
>>>import functools
>>>int2=functools.partial(int,base=2)
>>>int2('1000000')
64

>>>max2=functools.partial(max,10)
>>>max2(5,6,7)
10

#当函数的参数太多时，需要简化，使用functools.partial可以创建一个新函数，从而调用更简单

--模块
>>>import sys #使用sys模块
#类似__xxx__的变量是特殊变量，可以被直接引用，但是有特殊用途，如__author__,__name__
#类似_xxx和__xxx的变量就是非公开的变量(private)，不应该被直接引用
#安装第三方模块：pip install Pillow ，其中Pillow为第三方图像处理工具库
>>>from PIL import Image
>>>im=Image.open('test.png')
>>>print(im.format,im.size,im.mode)
PNG (400,300) RGB
>>>im.thumbnail((200,100))
>>>im.save('thumb.jpg','JPEG')
#常用的第三方库还有MySQL的驱动：mysql-connector-python，用于科学计算的NumPy库：numpy，用于生成文本的模板工具JinJa2
#搜索路径存放在sys模块的path变量中

#添加自己的搜索目录，有两种方法
#方法一：直接修改sys.path，添加要搜索的目录
>>>import sys
>>>sys.path.append('/Users/michael/my_py_scripts')
#方法二：设置环境变量PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中。设置方法与设置Path环境变量类似


--面向对象编程
class Student(object):   #object表示父类
    pass
#可以自由给实例变量绑定属性
>>>bart=Student()
>>>bart.name='Bart Simpson'
>>>bart.name
'Bart Simpson'

class Student(object):
    def __init__(self,name,score):  #第一个参数永远是self，表示创建的实例本身
        self.name=name
        self.score=score
>>>bart=Student('Bart Simpson',59)  #创建实例时，不能传入空的参数，必须传入与__init__方法匹配的参数，但self不需要传
>>>bart.name
'Bart Simpson'
>>>bart.score
59

#类中函数和普通参数相比：类中函数第一个参数永远是实例变量self，调用时不用传递该参数，其他都是一样

#数据封装
class Student(object):
    def __init__(self,name,score):  #第一个参数永远是self，表示创建的实例本身
        self.name=name
        self.score=score    
    def print_score(self):          #定义一个方法，第一个参数是self，其他和普通函数一样，调用时直接调用，self不用传递，其他参数正常传入
        print('%s:$s'%(self.name,self.score))
        
#访问限制
#如果让内部属性不被外部访问，可以在属性的名称前面加上两个下划线__
#python中，实例的变量名如果以__开头，就变成了一个私有变量(private)，只有内部可以访问，外部不能访问

#继承和多态
#继承可以把父类的所有功能都直接拿过来，子类只需新增自己特有的方法，也可以把父类方法覆盖重写
#Python是动态语言，则不一定需要传入Animal类型，我们只要保证传入的对象有一个run()方法就可以了
#动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的

#获取对象信息
#方法一：使用type()函数，type()返回的是对于的Class类型
#判断一个对象是否是函数，可以使用types模块中定义的常量
>>>import types
>>>def fn():
...     pass
...
>>>type(fn)==types.FunctionType
True
>>>type(abs)==types.BuiltinFunctionType
True
>>>type(lambda x:x)==types.LambdaType
True
>>>type((x for x in range(10)))==types.GeneratorType
True

#方法二：使用isinstance()
>>>h=Husky()
>>>isinstance(h,Husky)
True
>>>isinstance(h,Dog)
True
#isinstance()判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上
#能使用type()判断的基本类型也可以用isinstance()判断

#isinstance()还可以判断一个变量是否是某些类型中的一种
>>>isinstance([1,2,3],(list,tuple))
True

#方法三：使用dir()
#dir()用于获取对象的所有属性和方法，它返回一个包含字符串的list
>>>len('ABC')
3
>>>'ABC'.__len__()  #与len('ABC')等价
3

>>>class MyObject(object):
...     def __init__(self):
...         self.x=9
...     def power(self):
...         return self.x*self.x
...
>>>obj=MyObject()
>>>hasattr(obj,'x') #有属性'x'吗？
True
>>>hasattr(obj,'y') #有属性'y'吗？
False
>>>setattr(obj,'y',19) #设置属性'y'的值为19
>>>hasattr(obj,'y')
True
>>>getattr(obj,'y') #获取属性'y'
19
>>>getattr(obj,'z') #获取不存在的属性'z'，则会报错
>>>getattr(obj,'z',404)  #如果不存在'z'，返回默认值404
404

#也可以获取对象的方法
>>>hasattr(obj,'power')  #有‘power’方法吗？

#实例属性和类属性
#实例属性的优先级高于类属性
#注意：在编写程序时，实例属性和类属性不能用相同的名字，因为相同名称的实例属性会屏蔽掉类属性，
#但是当你删除实例属性时，再次使用相同的名称，访问的将是类的属性

--面向对象高级编程
#Python中对一个实例绑定的方法对另外一个实例不起作用
#为了给所有实例绑定方法，可以给class绑定方法
class Student(object):
    pass
def set_score(self,score):
...     self.score=score
...
>>>Student.set_score=MethodType(set_score,Student)  #给class绑定方法

#使用__slots__，可以限制class实例能添加的属性
class Student(object):
    __slots__=('name','age')  #用tuple定义允许绑定的属性名称
    
#使用__slots__定义的属性仅对当前类实例起作用，对继承的子类不起作用

#使用@property,可以把一个方法变为属性调用
class Student(object):
    @property
    def score(self):
        return self.score
    @score.setter
    def score(self,value):
        if not isinstance(value,int):
            raise ValueError('score must be an integer')
        if value <0 or value>100:
            raise ValueError('score must between 0-100!')
        self.score=value
>>>s=Student()
>>>s.core=60 #OK，实际转化为s.set_score(60)
>>>s.core    #实际转化为s.get_score()
60
>>>s.score=999
Traceback(most recent call last):
...
ValueError:score must between 0-100!

#多重继承
#通过多重继承，一个子类可以同时获得多个父类的所有功能
class Dog(Mammal,Runnable):   #狗类多继承哺乳类和能跑类
    pass
class Bat(Mammal,Flyable):    #蝙蝠类多继承哺乳类和能飞类
    pass
    
#MixIn的目的就是给一个类增加多个功能，这样，类设计时，我们优先考虑通过过继承来组合多个MixIn的功能，而不是设计多层次的复杂继承关系
